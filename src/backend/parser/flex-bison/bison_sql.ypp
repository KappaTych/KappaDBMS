%{
    #include "bison_sql.h"
    #include "flex_sql.h"

    #include <stdio.h>
    #include <string>


    int yyerror(YYLTYPE* llocp, yyscan_t scanner, const char *msg) {
        return 1;
    }
%}

// Specify code that is included in the generated .h and .c files
%code requires {

#include "../sql-stmt/Table.h"
#include "../sql-stmt/Expression.h"


#include "../../storage/datatypes/object.h"
#include "../../storage/StorageEngine.h"

#ifndef YYtypeDEF_YY_SCANNER_T
#define YYtypeDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

}

%output  "bison_sql.cpp"
%defines "bison_sql.h"

// Tell bison to create a reentrant parser
%define api.pure full

%locations

// For Pure Calling
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }


// Define all data-types
%union {
    int64_t ival;
    double fval;
    bool bval;
    std::string* strval;
    
    sql::TableName* table_name;
    sql::ColumnDefinition* column;
    sql::DataType column_type_t;
    sql::Expression* expr_t;

    std::vector<sql::ColumnDefinition>* column_vec;
    std::vector<std::string>* id_vec;
    std::vector<sql::Expression>* expr_vec;
}

//  Destructor
%destructor { } <ival> <fval> <bval> <column_type_t>
%destructor{ delete(($$)); } <table_name> <strval> <column> <expr_t> <column_vec> <id_vec> <expr_vec>


// Token definition

%token<strval> IDENTIFIER STRING BLOB_STRING
%token<ival> INT_CONST 
%token<bval> TRUE FALSE
%token<fval> DOUBLE_CONST


%token DOUBLE TEXT INTEGER
%token CREATE TABLE DROP SHOW NUL SELECT VALUES INTO INSERT FROM

// Non-terminal types

// %type       sql_stmt_list
// %type       statement
// %type       create_statement
// %type       drop_statement
// %type       show_statement

%type<table_name>      table_name
%type<column_type_t>   column_type
%type<column>        column_def
%type<column_vec>  column_def_commalist
%type<id_vec>	id_comma_list
%type<expr_vec>	expr_list
%type<expr_t> expr literal_value

// Token Precedence and Associativity

%left '(' ')'


%%

input:
        sql_stmt_list opt_semicolon
    ;

sql_stmt_list:
        statement 
    |   sql_stmt_list ';' statement
    ;

statement:
       create_statement
    |   drop_statement
    | 	show_statement
    |   select_statement
    | 	insert_statement
    ;


// Show Statement
show_statement:
        SHOW TABLE table_name {
        	se::StorageEngine& storage = se::StorageEngine::getInstance();
        	auto s = storage.show_create($3->name);

        	std::cout << s << std::endl;
        }
    ;

// Create Statement
create_statement:
	CREATE TABLE table_name '(' column_def_commalist ')' {
			se::StorageEngine& storage = se::StorageEngine::getInstance();
			nlohmann::fifo_map<std::string, dt::DataType> columns;
			
			for (auto &e : *$5) {
				columns[e.name] = sql::convertDbType(e.type);
			}

			storage.create($3->name, columns);
        }
    ;

column_def_commalist:
        column_def { 
            $$ = new std::vector<sql::ColumnDefinition>();
            $$->push_back(*$1);
        }
    |   column_def_commalist ',' column_def { 
            $1->push_back(*$3);
            $$ = $1; 
        }
    ;

column_def:
        IDENTIFIER column_type {
            $$ = new sql::ColumnDefinition(*($1), $2);
        }
    ;
column_type:
        INTEGER { $<column_type_t>$ = sql::DataType::INT; }
    |   DOUBLE { $$ = sql::DataType::DOUBLE; }
    |   TEXT { $$ = sql::DataType::TEXT; }
    ;

// Drop Statement
drop_statement:
        DROP TABLE table_name {
        	// drop 
        }
    ;

// Select Statement
select_statement:
	SELECT '*' FROM IDENTIFIER {}

// Inser Statement
insert_statement:
    INSERT INTO table_name '(' id_comma_list ')' VALUES '(' expr_list ')'
    ;


// Expression

expr_list: // TODO: base_list
        expr {
            $$ = new std::vector<sql::Expression>();
            $$->push_back(*$1);
        }
    |   expr_list ',' expr {
            $1->push_back(*$3);
            $$ = $1;
        }
    ;

expr:	
		literal_value
	;


literal_value:
		INT_CONST { $$ = sql::Expression::makeLiteral($1); }
	|	DOUBLE_CONST { $$ = sql::Expression::makeLiteral($1); }
	|	STRING { $$ = sql::Expression::makeLiteral(*($1)); }
	|	BLOB_STRING	{ $$ = sql::Expression::makeLiteral(*($1)); }
	|	NUL { $$ = sql::Expression::makeNullLiteral(); }
	|	TRUE { $$ = sql::Expression::makeLiteral($1); }
	|	FALSE { $$ = sql::Expression::makeLiteral($1); }

// Table

table_name:
		IDENTIFIER                {
		$$ = new sql::TableName("", *($1));
		}
	|	IDENTIFIER '.' IDENTIFIER {
	        $$ = new sql::TableName(*($1), *($3));
	    }
	;

// Misc

opt_semicolon:
	';'
|	/* empty */
;

id_comma_list:
         IDENTIFIER  {
             $$ = new std::vector<std::string>();
             $$->push_back(*$1);
         }
    |    id_comma_list ',' IDENTIFIER {
             $1->push_back(*$3);
             $$ = $1;
         }
    ;