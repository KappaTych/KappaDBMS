%code top {
    #include "bison_sql.hpp"
    #include "flex_sql.hpp"
    #include "../parser.hpp"

    #include <string>

    static yy::BisonParser::symbol_type yylex(yy::FlexScanner& scanner) {
        return scanner.get_next_token();
    }
}

%code requires {
    #include "../sql.hpp"

    namespace yy {
        class FlexScanner;
    }

    namespace sql {
        class Parser;
    }
}

%require "3.2"
%language "c++"
%define parser_class_name { BisonParser }

%define api.token.constructor
%define api.value.type variant

%locations

%lex-param   { yy::FlexScanner& scanner }
%parse-param { yy::FlexScanner& scanner }


// Token definition
%token<std::string> IDENTIFIER STRING BLOB_STRING
%token<long int> INTEGER_CONST
%token<bool> TRUE FALSE
%token<long double> DOUBLE_CONST


//%token DOUBLE TEXT INTEGER
%token CREATE TABLE DROP SHOW NULL_ SELECT VALUES INTO INSERT FROM
%token UPDATE SET WHERE LIMIT OFFSET
%token CAST AS ESCAPE ISNULL NOTNULL BETWEEN DISTINCT EXISTS WHEN
%token THEN ELSE NOT COLLATE IS IN LIKE GLOB MATCH REGEXP AND OR

%token EQUALL NOTEQUALL LESSEQUALL GREATEQUALL LESS GREATE
%token CONCATENATION LEFTSHIFT RIGHTSHIFT BINNOT BINAND BINOR
%token PLUS MINUS MULTI DIVISION MOD
%token SEMICOLON DOT COMMA OPENBRACKET CLOSEBRACKET
%token END
// Non-terminal types
//%type

// Token Precedence and Associativity
// lowest to highest
%left OR
%left AND
%right NOT
%precedence EQUALL NOTEQUALL LIKE GLOB MATCH REGEXP
%precedence LESS GREATE LESSEQUALL GREATEQUALL
%left LEFTSHIFT RIGHTSHIFT
%left BINOR
%left BINAND

%precedence NOTNULL
%precedence ISNULL
%precedence IS 
%right IN

%left PLUS MINUS
%left MULTI DIVISION MOD
%left CONCATENATION

%right UMINUS UPLUS
%right BINNOT
%right COLLATE

%left OPENBRACKET CLOSEBRACKET
%left DOT



%%
%start input;
input:
        sql_stmt_list opt_semicolon
    ;

sql_stmt_list:
        statement 
    |   sql_stmt_list SEMICOLON statement
    ;

statement:
        create_statement
    |   drop_statement
    |   show_statement
    |   select_statement
    |   insert_statement
    ;


// Show Statement
show_statement:
        SHOW TABLE table_name { }
    ;

// Create Statement
create_statement:
    CREATE TABLE table_name OPENBRACKET column_def_commalist CLOSEBRACKET {}
    ;

column_def_commalist:
        column_def {}
    |   column_def_commalist ',' column_def {}
    ;

column_def:
        IDENTIFIER column_type {}
    ;
column_type:
        IDENTIFIER
    ;

// Drop Statement
drop_statement:
        DROP TABLE table_name {}
    ;

// Select Statement
select_statement:
    SELECT '*' FROM IDENTIFIER {}

// Inser Statement
insert_statement:
    INSERT INTO table_name OPENBRACKET id_comma_list CLOSEBRACKET VALUES OPENBRACKET expr_list CLOSEBRACKET
    ;


// Expression

expr_list:
        expr {       }
    |   expr_list ',' expr {        }
    ;

expr:   
        literal_value
    ;


literal_value:
        INTEGER_CONST { }
    |   DOUBLE_CONST {  }
    |   STRING {  }
    |   BLOB_STRING {  }
    |   NULL_ {  }
    |   TRUE { }
    |   FALSE {  }

// Table

table_name:
        IDENTIFIER                {        }
    |   IDENTIFIER '.' IDENTIFIER {        }
    ;

// Misc

opt_semicolon:
    SEMICOLON
|   /* empty */
;

id_comma_list:
         IDENTIFIER  {         }
    |    id_comma_list ',' IDENTIFIER {         }
    ;