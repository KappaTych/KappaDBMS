%code top {
    #include "bison_sql.h"
    #include "flex_sql.h"

    #include <string>

    int yyerror(YYLTYPE* llocp, yyscan_t scanner, const char *msg) {
        return 1;
    }
}

// Specify code that is included in the generated .h and .c files
%code requires {

#include "../sql-stmt/Table.h"
#include "../sql-stmt/Expression.h"

#ifndef YYtypeDEF_YY_SCANNER_T
#define YYtypeDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

}

// Tell bison to create a reentrant parser
%define api.pure full

// For Pure Calling
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }


%define api.value.type union

// Token definition

%token<std::string> IDENTIFIER STRING BLOB_STRING
%token<long int> INT_CONST 
%token<bool> TRUE FALSE
%token<long double> DOUBLE_CONST


%token DOUBLE TEXT INTEGER
%token CREATE TABLE DROP SHOW NULL SELECT VALUES INTO INSERT FROM

// Non-terminal types

%type <sql::TableName>    table_name
%type <sql::DataType> column_type
%type <sql::ColumnDefinition>        column_def
%type < std::vector<sql::ColumnDefinition> >    column_def_commalist
%type < std::vector<std::string> >        id_comma_list
%type < std::vector<sql::Expression> >      expr_list
%type <sql::Expression> expr   literal_value

// Token Precedence and Associativity

%left '(' ')'


%%

input:
        sql_stmt_list opt_semicolon
    ;

sql_stmt_list:
        statement 
    |   sql_stmt_list ';' statement
    ;

statement:
        create_statement
    |   drop_statement
    |   show_statement
    |   select_statement
    |   insert_statement
    ;


// Show Statement
show_statement:
        SHOW TABLE table_name {
            se::StorageEngine& storage = se::StorageEngine::Instance();
            auto s = storage.show_create($3->name);

            std::cout << s << std::endl;
        }
    ;

// Create Statement
create_statement:
    CREATE TABLE table_name '(' column_def_commalist ')' {
            se::StorageEngine& storage = se::StorageEngine::Instance();
            nlohmann::fifo_map<std::string, dt::DataType> columns;
            
            for (auto &e : *$5) {
                columns[e.name] = sql::convertDbType(e.type);
            }

            storage.create($3->name, columns);
        }
    ;

column_def_commalist:
        column_def { 
            $$ = new std::vector<sql::ColumnDefinition>();
            $$->push_back(*$1);
        }
    |   column_def_commalist ',' column_def { 
            $1->push_back(*$3);
            $$ = $1; 
        }
    ;

column_def:
        IDENTIFIER column_type {
            $$ = new sql::ColumnDefinition(*($1), $2);
        }
    ;
column_type:
        INTEGER { $<column_type_t>$ = sql::DataType::INT; }
    |   DOUBLE { $$ = sql::DataType::DOUBLE; }
    |   TEXT { $$ = sql::DataType::TEXT; }
    ;

// Drop Statement
drop_statement:
        DROP TABLE table_name {
            // drop 
        }
    ;

// Select Statement
select_statement:
    SELECT '*' FROM IDENTIFIER {}

// Inser Statement
insert_statement:
    INSERT INTO table_name '(' id_comma_list ')' VALUES '(' expr_list ')'
    ;


// Expression

expr_list: // TODO: base_list
        expr {
            $$ = new std::vector<sql::Expression>();
            $$->push_back(*$1);
        }
    |   expr_list ',' expr {
            $1->push_back(*$3);
            $$ = $1;
        }
    ;

expr:   
        literal_value
    ;


literal_value:
        INT_CONST { $$ = sql::Expression::makeLiteral($1); }
    |   DOUBLE_CONST { $$ = sql::Expression::makeLiteral($1); }
    |   STRING { $$ = sql::Expression::makeLiteral(*($1)); }
    |   BLOB_STRING { $$ = sql::Expression::makeLiteral(*($1)); }
    |   NULL { $$ = sql::Expression::makeNullLiteral(); }
    |   TRUE { $$ = sql::Expression::makeLiteral($1); }
    |   FALSE { $$ = sql::Expression::makeLiteral($1); }

// Table

table_name:
        IDENTIFIER                {
        $$ = new sql::TableName("", *($1));
        }
    |   IDENTIFIER '.' IDENTIFIER {
            $$ = new sql::TableName(*($1), *($3));
        }
    ;

// Misc

opt_semicolon:
    ';'
|   /* empty */
;

id_comma_list:
         IDENTIFIER  {
             $$ = new std::vector<std::string>();
             $$->push_back(*$1);
         }
    |    id_comma_list ',' IDENTIFIER {
             $1->push_back(*$3);
             $$ = $1;
         }
    ;