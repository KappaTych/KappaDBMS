%code top {
    #include "bison_sql.hpp"
    #include "flex_sql.hpp"
    #include "../parser.hpp"

    #include <string>

    static yy::BisonParser::symbol_type yylex(yy::FlexScanner& scanner) {
        return scanner.get_next_token();
    }

    void yy::BisonParser::error(yy::location const&, const std::string&) {}
}

%code requires {
    #include <memory>
    #include "../sql.hpp"

    namespace yy {
        class FlexScanner;
    }

    namespace sql {
        class Parser;
    }
}

%require "3.2"
%language "c++"
%define parser_class_name { BisonParser }

%define api.token.constructor
%define api.value.type variant

%locations

%lex-param   { yy::FlexScanner& scanner }
%parse-param { yy::FlexScanner& scanner }
%parse-param { sql::Parser& driver }

// Token definition
%token<std::string> IDENTIFIER STRING BLOB_STRING
%token<long int> INTEGER_CONST
%token<bool> TRUE FALSE
%token<long double> DOUBLE_CONST


//%token DOUBLE TEXT INTEGER
%token CREATE TABLE DROP SHOW NULL_ SELECT VALUES INTO INSERT FROM
%token UPDATE SET WHERE LIMIT OFFSET
%token CAST AS ESCAPE ISNULL NOTNULL BETWEEN DISTINCT EXISTS WHEN
%token THEN ELSE NOT COLLATE IS IN LIKE GLOB MATCH REGEXP AND OR

%token EQUAL NOTEQUAL LESSEQUAL GREATERQUALL LESS GREATER
%token CONCATENATION LEFTSHIFT RIGHTSHIFT BINNOT BINAND BINOR
%token PLUS MINUS MULTIPLY DIVISION MOD
%token SEMICOLON DOT COMMA OPENBRACKET CLOSEBRACKET
%token UMINUS UPLUS
%token END

// Non-terminal types
%type <std::shared_ptr<cmd::Expression>> expr operand
%type <std::shared_ptr<cmd::Expression>> unary_operator binary_operator
%type <std::shared_ptr<cmd::Expression>> logical_operator
%type <std::shared_ptr<cmd::Expression>> scalar_expr literal_value column_name
//%type <std::shared_ptr<cmd::Expression>>


// Token Precedence and Associativity
// lowest to highest
%left OR
%left AND
%nonassoc IN IS ISNULL NOTNULL LIKE GLOB MATCH REGEXP
%left NOT
%left BETWEEN
%nonassoc EQUAL NOTEQUAL
%nonassoc LESS GREATER LESSEQUAL GREATERQUALL

%left BINOR
%left BINAND
%left LEFTSHIFT RIGHTSHIFT

%left PLUS MINUS
%left MULTIPLY DIVISION MOD
%left CONCATENATION

%right UMINUS UPLUS
%right BINNOT
%right COLLATE

%left OPENBRACKET CLOSEBRACKET
%left DOT



%%
%start input;
input:
        sql_stmt_list opt_semicolon
    ;

sql_stmt_list:
        statement 
    |   sql_stmt_list SEMICOLON statement
    ;

statement:
        create_statement
    |   drop_statement
    |   show_statement
    |   select_statement
    |   insert_statement
    ;


// Show Statement
show_statement:
        SHOW TABLE table_name { }
    ;

// Create Statement
create_statement:
    CREATE TABLE table_name OPENBRACKET column_def_commalist CLOSEBRACKET {}
    ;

column_def_commalist:
        column_def {}
    |   column_def_commalist ',' column_def {}
    ;

column_def:
        IDENTIFIER column_type {}
    ;
column_type:
        IDENTIFIER
    ;

// Drop Statement
drop_statement:
        DROP TABLE table_name {}
    ;

// Select Statement
select_statement:
    SELECT '*' FROM IDENTIFIER {}

// Inser Statement
insert_statement:
    INSERT INTO table_name OPENBRACKET id_comma_list CLOSEBRACKET VALUES OPENBRACKET expr_list CLOSEBRACKET
    ;


// Expression


expr_list:
        expr {       }
    |   expr_list ',' expr {        }
    ;


expr:   
        operand
    |   logical_operator
    ;

operand:
        OPENBRACKET expr CLOSEBRACKET { $$ = $2; }
    |   scalar_expr
    |   unary_operator
    |   binary_operator
    ;

unary_operator:
        MINUS operand %prec UMINUS { $$ = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::UNARY_MINUS, $2); } // TODO
    |   PLUS operand %prec UPLUS { $$ = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::UNARY_PLUS, $2); }
    |   BINNOT  operand { $$ = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::BIN_NOT, $2); }
    |   NOT operand { $$ = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::NOT, $2); }
    |   operand ISNULL { $$ = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::ISNULL, $1); }
    |   operand NOTNULL 
        {
            auto nodeIsNull = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::ISNULL, $1);
            $$ = std::make_shared<cmd::UnaryOperation>(cmd::OperationType::NOT, nodeIsNull);
        }
    ;

binary_operator:
        operand LESS operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::LESS, $1, $3); }
    |   operand GREATER operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::GREATER, $1, $3); }
    |   operand EQUAL operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::EQUAL, $1, $3); }
    |   operand NOTEQUAL operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::NOT_EQUAL, $1, $3); }
    |   operand LESSEQUAL operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::LESS_EQUAL, $1, $3); }
    |   operand GREATERQUALL operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::GREATER_EQUAL, $1, $3); }
    |   operand PLUS operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::PLUS, $1, $3); }
    |   operand MINUS operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::MINUS, $1, $3); }
    |   operand MULTIPLY operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::MULTIPLY, $1, $3); }
    |   operand DIVISION operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::DIVISION, $1, $3); }
    |   operand MOD operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::MOD, $1, $3); }
    |   operand CONCATENATION operand { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::CONCATENATION, $1, $3); }
    ;

logical_operator:
        expr AND expr { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::AND, $1, $3); } 
    |   expr OR expr { $$ = std::make_shared<cmd::BinaryOperation>(cmd::OperationType::OR, $1, $3); }
    ;

scalar_expr:
        literal_value
    |   column_name
    ;

literal_value:
        INTEGER_CONST { $$ = std::make_shared<cmd::Literal>($1); }
    |   DOUBLE_CONST { $$ = std::make_shared<cmd::Literal>($1); }
    |   STRING { $$ = std::make_shared<cmd::Literal>($1); }
    |   BLOB_STRING { $$ = std::make_shared<cmd::Literal>($1); }
    |   NULL_ { $$ = std::make_shared<cmd::Literal>(); }
    |   TRUE { $$ = std::make_shared<cmd::Literal>($1); }
    |   FALSE { $$ = std::make_shared<cmd::Literal>($1); }

column_name:
        IDENTIFIER  { $$ = std::make_shared<cmd::Column>($1); } 
    |   IDENTIFIER DOT IDENTIFIER   { $$ = std::make_shared<cmd::Column>($3, $1); }
    |   IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER { $$ = std::make_shared<cmd::Column>($5, $3, $1); }
    ;

// Table

table_name:
        IDENTIFIER                {        }
    |   IDENTIFIER '.' IDENTIFIER {        }
    ;

// Misc

opt_semicolon:
    SEMICOLON
|   %empty
;

id_comma_list:
         IDENTIFIER  {         }
    |    id_comma_list ',' IDENTIFIER {         }
    ;
